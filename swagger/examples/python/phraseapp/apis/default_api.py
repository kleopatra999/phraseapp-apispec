# coding: utf-8

"""
    PhraseApp

    PhraseApp API for the interaction with the PhraseApp localization platform

    OpenAPI spec version: 2.0
    Contact: support@phraseapp.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accounts_account_id_glossaries_get(self, account_id, **kwargs):
        """
        List all glossaries the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_get(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Glossary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_get_with_http_info(account_id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_get_with_http_info(account_id, **kwargs)
            return data

    def accounts_account_id_glossaries_get_with_http_info(self, account_id, **kwargs):
        """
        List all glossaries the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_get_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Glossary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Glossary]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_get(self, account_id, glossary_id, **kwargs):
        """
        List all glossary terms the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_get(account_id, glossary_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[GlossaryTerm]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_get_with_http_info(account_id, glossary_id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_get_with_http_info(account_id, glossary_id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_get_with_http_info(self, account_id, glossary_id, **kwargs):
        """
        List all glossary terms the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_get_with_http_info(account_id, glossary_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[GlossaryTerm]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_get`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GlossaryTerm]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_id_delete(self, account_id, glossary_id, id, **kwargs):
        """
        Delete an existing glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_id_delete(account_id, glossary_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_id_delete_with_http_info(account_id, glossary_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_id_delete_with_http_info(account_id, glossary_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_id_delete_with_http_info(self, account_id, glossary_id, id, **kwargs):
        """
        Delete an existing glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_id_delete_with_http_info(account_id, glossary_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_delete`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_id_get(self, account_id, glossary_id, id, **kwargs):
        """
        Get details on a single glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_id_get(account_id, glossary_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str id: Id (required)
        :return: GlossaryTerm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_id_get_with_http_info(account_id, glossary_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_id_get_with_http_info(account_id, glossary_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_id_get_with_http_info(self, account_id, glossary_id, id, **kwargs):
        """
        Get details on a single glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_id_get_with_http_info(account_id, glossary_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str id: Id (required)
        :return: GlossaryTerm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_get`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GlossaryTerm',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_id_patch(self, account_id, glossary_id, id, **kwargs):
        """
        Update an existing glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_id_patch(account_id, glossary_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str id: Id (required)
        :return: GlossaryTerm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_id_patch_with_http_info(account_id, glossary_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_id_patch_with_http_info(account_id, glossary_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_id_patch_with_http_info(self, account_id, glossary_id, id, **kwargs):
        """
        Update an existing glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_id_patch_with_http_info(account_id, glossary_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str id: Id (required)
        :return: GlossaryTerm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_patch`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_glossary_id_terms_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GlossaryTerm',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_post(self, account_id, glossary_id, **kwargs):
        """
        Create a new glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_post(account_id, glossary_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :return: GlossaryTerm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_post_with_http_info(account_id, glossary_id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_post_with_http_info(account_id, glossary_id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_post_with_http_info(self, account_id, glossary_id, **kwargs):
        """
        Create a new glossary term.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_post_with_http_info(account_id, glossary_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :return: GlossaryTerm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_post`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_post`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GlossaryTerm',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete(self, account_id, glossary_id, term_id, id, **kwargs):
        """
        Delete an existing glossary term translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete(account_id, glossary_id, term_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str term_id: TermId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete_with_http_info(account_id, glossary_id, term_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete_with_http_info(account_id, glossary_id, term_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete_with_http_info(self, account_id, glossary_id, term_id, id, **kwargs):
        """
        Delete an existing glossary term translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete_with_http_info(account_id, glossary_id, term_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str term_id: TermId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'term_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete`")
        # verify the required parameter 'term_id' is set
        if ('term_id' not in params) or (params['term_id'] is None):
            raise ValueError("Missing the required parameter `term_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']
        if 'term_id' in params:
            path_params['TermId'] = params['term_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms/{TermId}/translations/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch(self, account_id, glossary_id, term_id, id, **kwargs):
        """
        Update an existing glossary term translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch(account_id, glossary_id, term_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str term_id: TermId (required)
        :param str id: Id (required)
        :return: GlossaryTermTranslation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch_with_http_info(account_id, glossary_id, term_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch_with_http_info(account_id, glossary_id, term_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch_with_http_info(self, account_id, glossary_id, term_id, id, **kwargs):
        """
        Update an existing glossary term translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch_with_http_info(account_id, glossary_id, term_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str term_id: TermId (required)
        :param str id: Id (required)
        :return: GlossaryTermTranslation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'term_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch`")
        # verify the required parameter 'term_id' is set
        if ('term_id' not in params) or (params['term_id'] is None):
            raise ValueError("Missing the required parameter `term_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']
        if 'term_id' in params:
            path_params['TermId'] = params['term_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms/{TermId}/translations/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GlossaryTermTranslation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post(self, account_id, glossary_id, term_id, **kwargs):
        """
        Create a new glossary term translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post(account_id, glossary_id, term_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str term_id: TermId (required)
        :return: GlossaryTermTranslation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post_with_http_info(account_id, glossary_id, term_id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post_with_http_info(account_id, glossary_id, term_id, **kwargs)
            return data

    def accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post_with_http_info(self, account_id, glossary_id, term_id, **kwargs):
        """
        Create a new glossary term translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post_with_http_info(account_id, glossary_id, term_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str glossary_id: GlossaryId (required)
        :param str term_id: TermId (required)
        :return: GlossaryTermTranslation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'glossary_id', 'term_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post`")
        # verify the required parameter 'glossary_id' is set
        if ('glossary_id' not in params) or (params['glossary_id'] is None):
            raise ValueError("Missing the required parameter `glossary_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post`")
        # verify the required parameter 'term_id' is set
        if ('term_id' not in params) or (params['term_id'] is None):
            raise ValueError("Missing the required parameter `term_id` when calling `accounts_account_id_glossaries_glossary_id_terms_term_id_translations_post`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'glossary_id' in params:
            path_params['GlossaryId'] = params['glossary_id']
        if 'term_id' in params:
            path_params['TermId'] = params['term_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{GlossaryId}/terms/{TermId}/translations', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='GlossaryTermTranslation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_id_delete(self, account_id, id, **kwargs):
        """
        Delete an existing glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_id_delete(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_id_delete_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_id_delete_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_id_delete_with_http_info(self, account_id, id, **kwargs):
        """
        Delete an existing glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_id_delete_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_id_get(self, account_id, id, **kwargs):
        """
        Get details on a single glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_id_get(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Glossary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_id_get_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_id_get_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_id_get_with_http_info(self, account_id, id, **kwargs):
        """
        Get details on a single glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_id_get_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Glossary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_id_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Glossary',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_id_patch(self, account_id, id, **kwargs):
        """
        Update an existing glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_id_patch(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Glossary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_id_patch_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_id_patch_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_glossaries_id_patch_with_http_info(self, account_id, id, **kwargs):
        """
        Update an existing glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_id_patch_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Glossary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_glossaries_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Glossary',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_glossaries_post(self, account_id, **kwargs):
        """
        Create a new glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_post(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :return: Glossary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_glossaries_post_with_http_info(account_id, **kwargs)
        else:
            (data) = self.accounts_account_id_glossaries_post_with_http_info(account_id, **kwargs)
            return data

    def accounts_account_id_glossaries_post_with_http_info(self, account_id, **kwargs):
        """
        Create a new glossary.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_glossaries_post_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :return: Glossary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_glossaries_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_glossaries_post`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/glossaries', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Glossary',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_invitations_get(self, account_id, **kwargs):
        """
        List invitations for an account. It will also list the accessible resources like projects and locales the invited user has access to. In case nothing is shown the default access from the role is used. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_get(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Invitation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_invitations_get_with_http_info(account_id, **kwargs)
        else:
            (data) = self.accounts_account_id_invitations_get_with_http_info(account_id, **kwargs)
            return data

    def accounts_account_id_invitations_get_with_http_info(self, account_id, **kwargs):
        """
        List invitations for an account. It will also list the accessible resources like projects and locales the invited user has access to. In case nothing is shown the default access from the role is used. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_get_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Invitation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_invitations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_invitations_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/invitations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Invitation]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_invitations_id_delete(self, account_id, id, **kwargs):
        """
        Delete an existing invitation (must not be accepted yet). Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_delete(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_invitations_id_delete_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_invitations_id_delete_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_invitations_id_delete_with_http_info(self, account_id, id, **kwargs):
        """
        Delete an existing invitation (must not be accepted yet). Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_delete_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_invitations_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_invitations_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_invitations_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/invitations/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_invitations_id_get(self, account_id, id, **kwargs):
        """
        Get details on a single invitation. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_get(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_invitations_id_get_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_invitations_id_get_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_invitations_id_get_with_http_info(self, account_id, id, **kwargs):
        """
        Get details on a single invitation. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_get_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_invitations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_invitations_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_invitations_id_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/invitations/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_invitations_id_patch(self, account_id, id, **kwargs):
        """
        Update an existing invitation (must not be accepted yet). The <code>email</code> cannot be updated. Developers and translators need <code>project_ids</code> and <code>locale_ids</code> assigned to access them. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_patch(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_invitations_id_patch_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_invitations_id_patch_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_invitations_id_patch_with_http_info(self, account_id, id, **kwargs):
        """
        Update an existing invitation (must not be accepted yet). The <code>email</code> cannot be updated. Developers and translators need <code>project_ids</code> and <code>locale_ids</code> assigned to access them. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_patch_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_invitations_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_invitations_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_invitations_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/invitations/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_invitations_id_resend_post(self, account_id, id, **kwargs):
        """
        Resend the invitation email (must not be accepted yet). Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_resend_post(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_invitations_id_resend_post_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_invitations_id_resend_post_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_invitations_id_resend_post_with_http_info(self, account_id, id, **kwargs):
        """
        Resend the invitation email (must not be accepted yet). Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_id_resend_post_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_invitations_id_resend_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_invitations_id_resend_post`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_invitations_id_resend_post`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/invitations/{Id}/resend', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_invitations_post(self, account_id, **kwargs):
        """
        Invite a person to an account. Developers and translators need <code>project_ids</code> and <code>locale_ids</code> assigned to access them. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_post(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_invitations_post_with_http_info(account_id, **kwargs)
        else:
            (data) = self.accounts_account_id_invitations_post_with_http_info(account_id, **kwargs)
            return data

    def accounts_account_id_invitations_post_with_http_info(self, account_id, **kwargs):
        """
        Invite a person to an account. Developers and translators need <code>project_ids</code> and <code>locale_ids</code> assigned to access them. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_invitations_post_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :return: Invitation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_invitations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_invitations_post`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/invitations', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Invitation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_members_get(self, account_id, **kwargs):
        """
        Get all users active in the account. It also lists resources like projects and locales the member has access to. In case nothing is shown the default access from the role is used. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_get(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Member]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_members_get_with_http_info(account_id, **kwargs)
        else:
            (data) = self.accounts_account_id_members_get_with_http_info(account_id, **kwargs)
            return data

    def accounts_account_id_members_get_with_http_info(self, account_id, **kwargs):
        """
        Get all users active in the account. It also lists resources like projects and locales the member has access to. In case nothing is shown the default access from the role is used. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_get_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Member]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_members_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_members_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/members', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Member]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_members_id_delete(self, account_id, id, **kwargs):
        """
        Remove a user from the account. The user will be removed from the account but not deleted from PhraseApp. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_id_delete(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_members_id_delete_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_members_id_delete_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_members_id_delete_with_http_info(self, account_id, id, **kwargs):
        """
        Remove a user from the account. The user will be removed from the account but not deleted from PhraseApp. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_id_delete_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_members_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_members_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_members_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/members/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_members_id_get(self, account_id, id, **kwargs):
        """
        Get details on a single user in the account. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_id_get(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Member
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_members_id_get_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_members_id_get_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_members_id_get_with_http_info(self, account_id, id, **kwargs):
        """
        Get details on a single user in the account. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_id_get_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Member
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_members_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_members_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_members_id_get`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/members/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Member',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_account_id_members_id_patch(self, account_id, id, **kwargs):
        """
        Update user permissions in the account. Developers and translators need <code>project_ids</code> and <code>locale_ids</code> assigned to access them. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_id_patch(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Member
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_account_id_members_id_patch_with_http_info(account_id, id, **kwargs)
        else:
            (data) = self.accounts_account_id_members_id_patch_with_http_info(account_id, id, **kwargs)
            return data

    def accounts_account_id_members_id_patch_with_http_info(self, account_id, id, **kwargs):
        """
        Update user permissions in the account. Developers and translators need <code>project_ids</code> and <code>locale_ids</code> assigned to access them. Access token scope must include <code>team.manage</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_account_id_members_id_patch_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: AccountId (required)
        :param str id: Id (required)
        :return: Member
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_account_id_members_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `accounts_account_id_members_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_account_id_members_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountId'] = params['account_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{AccountId}/members/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Member',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_get(self, **kwargs):
        """
        List all accounts the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_get_with_http_info(**kwargs)
        else:
            (data) = self.accounts_get_with_http_info(**kwargs)
            return data

    def accounts_get_with_http_info(self, **kwargs):
        """
        List all accounts the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Account]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def accounts_id_get(self, id, **kwargs):
        """
        Get details on a single account.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_id_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accounts_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.accounts_id_get_with_http_info(id, **kwargs)
            return data

    def accounts_id_get_with_http_info(self, id, **kwargs):
        """
        Get details on a single account.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accounts_id_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `accounts_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/accounts/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Account',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def authorizations_get(self, **kwargs):
        """
        List all your authorizations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Authorization]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.authorizations_get_with_http_info(**kwargs)
        else:
            (data) = self.authorizations_get_with_http_info(**kwargs)
            return data

    def authorizations_get_with_http_info(self, **kwargs):
        """
        List all your authorizations.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Authorization]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorizations_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/authorizations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Authorization]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def authorizations_id_delete(self, id, **kwargs):
        """
        Delete an existing authorization. API calls using that token will stop working.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_id_delete(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.authorizations_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.authorizations_id_delete_with_http_info(id, **kwargs)
            return data

    def authorizations_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing authorization. API calls using that token will stop working.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_id_delete_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorizations_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `authorizations_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/authorizations/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def authorizations_id_get(self, id, **kwargs):
        """
        Get details on a single authorization.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_id_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Authorization
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.authorizations_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.authorizations_id_get_with_http_info(id, **kwargs)
            return data

    def authorizations_id_get_with_http_info(self, id, **kwargs):
        """
        Get details on a single authorization.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_id_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Authorization
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorizations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `authorizations_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/authorizations/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Authorization',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def authorizations_id_patch(self, id, **kwargs):
        """
        Update an existing authorization.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_id_patch(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Authorization
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.authorizations_id_patch_with_http_info(id, **kwargs)
        else:
            (data) = self.authorizations_id_patch_with_http_info(id, **kwargs)
            return data

    def authorizations_id_patch_with_http_info(self, id, **kwargs):
        """
        Update an existing authorization.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_id_patch_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Authorization
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorizations_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `authorizations_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/authorizations/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Authorization',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def authorizations_post(self, **kwargs):
        """
        Create a new authorization.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_post(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AuthorizationWithToken
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.authorizations_post_with_http_info(**kwargs)
        else:
            (data) = self.authorizations_post_with_http_info(**kwargs)
            return data

    def authorizations_post_with_http_info(self, **kwargs):
        """
        Create a new authorization.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.authorizations_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AuthorizationWithToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorizations_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/authorizations', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AuthorizationWithToken',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def formats_get(self, **kwargs):
        """
        Get a handy list of all localization file formats supported in PhraseApp.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.formats_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Format]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.formats_get_with_http_info(**kwargs)
        else:
            (data) = self.formats_get_with_http_info(**kwargs)
            return data

    def formats_get_with_http_info(self, **kwargs):
        """
        Get a handy list of all localization file formats supported in PhraseApp.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.formats_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Format]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method formats_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/formats', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Format]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_get(self, **kwargs):
        """
        List all projects the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_get_with_http_info(**kwargs)
        else:
            (data) = self.projects_get_with_http_info(**kwargs)
            return data

    def projects_get_with_http_info(self, **kwargs):
        """
        List all projects the current user has access to.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Project]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_id_delete(self, id, **kwargs):
        """
        Delete an existing project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_id_delete(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.projects_id_delete_with_http_info(id, **kwargs)
            return data

    def projects_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete an existing project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_id_delete_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_id_get(self, id, **kwargs):
        """
        Get details on a single project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_id_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.projects_id_get_with_http_info(id, **kwargs)
            return data

    def projects_id_get_with_http_info(self, id, **kwargs):
        """
        Get details on a single project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_id_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_id_patch(self, id, **kwargs):
        """
        Update an existing project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_id_patch(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: ProjectDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_id_patch_with_http_info(id, **kwargs)
        else:
            (data) = self.projects_id_patch_with_http_info(id, **kwargs)
            return data

    def projects_id_patch_with_http_info(self, id, **kwargs):
        """
        Update an existing project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_id_patch_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Id (required)
        :return: ProjectDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProjectDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_post(self, **kwargs):
        """
        Create a new project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_post(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ProjectDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_post_with_http_info(**kwargs)
        else:
            (data) = self.projects_post_with_http_info(**kwargs)
            return data

    def projects_post_with_http_info(self, **kwargs):
        """
        Create a new project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ProjectDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProjectDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_blacklisted_keys_get(self, project_id, **kwargs):
        """
        List all rules for blacklisting keys for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[BlacklistedKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_blacklisted_keys_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_blacklisted_keys_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_blacklisted_keys_get_with_http_info(self, project_id, **kwargs):
        """
        List all rules for blacklisting keys for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[BlacklistedKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_blacklisted_keys_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_blacklisted_keys_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/blacklisted_keys', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[BlacklistedKey]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_blacklisted_keys_id_delete(self, project_id, id, **kwargs):
        """
        Delete an existing rule for blacklisting keys.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_id_delete(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_blacklisted_keys_id_delete_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_blacklisted_keys_id_delete_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_blacklisted_keys_id_delete_with_http_info(self, project_id, id, **kwargs):
        """
        Delete an existing rule for blacklisting keys.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_id_delete_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_blacklisted_keys_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_blacklisted_keys_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_blacklisted_keys_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/blacklisted_keys/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_blacklisted_keys_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single rule for blacklisting keys for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: BlacklistedKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_blacklisted_keys_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_blacklisted_keys_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_blacklisted_keys_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single rule for blacklisting keys for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: BlacklistedKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_blacklisted_keys_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_blacklisted_keys_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_blacklisted_keys_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/blacklisted_keys/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BlacklistedKey',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_blacklisted_keys_id_patch(self, project_id, id, **kwargs):
        """
        Update an existing rule for blacklisting keys.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_id_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: BlacklistedKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_blacklisted_keys_id_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_blacklisted_keys_id_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_blacklisted_keys_id_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Update an existing rule for blacklisting keys.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_id_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: BlacklistedKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_blacklisted_keys_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_blacklisted_keys_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_blacklisted_keys_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/blacklisted_keys/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BlacklistedKey',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_blacklisted_keys_post(self, project_id, **kwargs):
        """
        Create a new rule for blacklisting keys.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: BlacklistedKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_blacklisted_keys_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_blacklisted_keys_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_blacklisted_keys_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new rule for blacklisting keys.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_blacklisted_keys_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: BlacklistedKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_blacklisted_keys_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_blacklisted_keys_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/blacklisted_keys', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BlacklistedKey',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_delete(self, project_id, **kwargs):
        """
        Delete all keys matching query. Same constraints as list. Please limit the number of affected keys to about 1,000 as you might experience timeouts otherwise.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_delete(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_delete_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_delete_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_keys_delete_with_http_info(self, project_id, **kwargs):
        """
        Delete all keys matching query. Same constraints as list. Please limit the number of affected keys to about 1,000 as you might experience timeouts otherwise.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_delete_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedResources',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_get(self, project_id, **kwargs):
        """
        List all keys for the given project. Alternatively you can POST requests to /search.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_keys_get_with_http_info(self, project_id, **kwargs):
        """
        List all keys for the given project. Alternatively you can POST requests to /search.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[TranslationKey]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_id_delete(self, project_id, id, **kwargs):
        """
        Delete an existing key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_id_delete(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_id_delete_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_id_delete_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_keys_id_delete_with_http_info(self, project_id, id, **kwargs):
        """
        Delete an existing key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_id_delete_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single key for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_keys_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single key for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationKey',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_id_patch(self, project_id, id, **kwargs):
        """
        Update an existing key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_id_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationKeyDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_id_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_id_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_keys_id_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Update an existing key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_id_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationKeyDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationKeyDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_get(self, project_id, key_id, **kwargs):
        """
        List all comments for a key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_get(project_id, key_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Comment]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_get_with_http_info(project_id, key_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_get_with_http_info(project_id, key_id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_get_with_http_info(self, project_id, key_id, **kwargs):
        """
        List all comments for a key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_get_with_http_info(project_id, key_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Comment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_get`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Comment]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_id_delete(self, project_id, key_id, id, **kwargs):
        """
        Delete an existing comment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_delete(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_id_delete_with_http_info(project_id, key_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_id_delete_with_http_info(project_id, key_id, id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_id_delete_with_http_info(self, project_id, key_id, id, **kwargs):
        """
        Delete an existing comment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_delete_with_http_info(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_id_delete`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_key_id_comments_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_id_get(self, project_id, key_id, id, **kwargs):
        """
        Get details on a single comment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_get(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_id_get_with_http_info(project_id, key_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_id_get_with_http_info(project_id, key_id, id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_id_get_with_http_info(self, project_id, key_id, id, **kwargs):
        """
        Get details on a single comment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_get_with_http_info(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_id_get`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_key_id_comments_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Comment',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_id_patch(self, project_id, key_id, id, **kwargs):
        """
        Update an existing comment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_patch(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_id_patch_with_http_info(project_id, key_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_id_patch_with_http_info(project_id, key_id, id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_id_patch_with_http_info(self, project_id, key_id, id, **kwargs):
        """
        Update an existing comment.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_patch_with_http_info(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_id_patch`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_key_id_comments_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Comment',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_id_read_delete(self, project_id, key_id, id, **kwargs):
        """
        Mark a comment as unread.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_read_delete(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_id_read_delete_with_http_info(project_id, key_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_id_read_delete_with_http_info(project_id, key_id, id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_id_read_delete_with_http_info(self, project_id, key_id, id, **kwargs):
        """
        Mark a comment as unread.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_read_delete_with_http_info(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_id_read_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_id_read_delete`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_id_read_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_key_id_comments_id_read_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments/{Id}/read', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_id_read_get(self, project_id, key_id, id, **kwargs):
        """
        Check if comment was marked as read. Returns 204 if read, 404 if unread.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_read_get(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_id_read_get_with_http_info(project_id, key_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_id_read_get_with_http_info(project_id, key_id, id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_id_read_get_with_http_info(self, project_id, key_id, id, **kwargs):
        """
        Check if comment was marked as read. Returns 204 if read, 404 if unread.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_read_get_with_http_info(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_id_read_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_id_read_get`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_id_read_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_key_id_comments_id_read_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments/{Id}/read', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_id_read_patch(self, project_id, key_id, id, **kwargs):
        """
        Mark a comment as read.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_read_patch(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_id_read_patch_with_http_info(project_id, key_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_id_read_patch_with_http_info(project_id, key_id, id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_id_read_patch_with_http_info(self, project_id, key_id, id, **kwargs):
        """
        Mark a comment as read.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_id_read_patch_with_http_info(project_id, key_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_id_read_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_id_read_patch`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_id_read_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_keys_key_id_comments_id_read_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments/{Id}/read', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_comments_post(self, project_id, key_id, **kwargs):
        """
        Create a new comment for a key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_post(project_id, key_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_comments_post_with_http_info(project_id, key_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_comments_post_with_http_info(project_id, key_id, **kwargs)
            return data

    def projects_project_id_keys_key_id_comments_post_with_http_info(self, project_id, key_id, **kwargs):
        """
        Create a new comment for a key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_comments_post_with_http_info(project_id, key_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_comments_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_comments_post`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_comments_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/comments', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Comment',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_key_id_translations_get(self, project_id, key_id, **kwargs):
        """
        List translations for a specific key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_translations_get(project_id, key_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: Translation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_key_id_translations_get_with_http_info(project_id, key_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_key_id_translations_get_with_http_info(project_id, key_id, **kwargs)
            return data

    def projects_project_id_keys_key_id_translations_get_with_http_info(self, project_id, key_id, **kwargs):
        """
        List translations for a specific key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_key_id_translations_get_with_http_info(project_id, key_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str key_id: KeyId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: Translation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'key_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_key_id_translations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_key_id_translations_get`")
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `projects_project_id_keys_key_id_translations_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'key_id' in params:
            path_params['KeyId'] = params['key_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/{KeyId}/translations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Translation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_post(self, project_id, **kwargs):
        """
        Create a new key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TranslationKeyDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_keys_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new key.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TranslationKeyDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationKeyDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_search_post(self, project_id, **kwargs):
        """
        Search keys for the given project matching query.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_search_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_search_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_search_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_keys_search_post_with_http_info(self, project_id, **kwargs):
        """
        Search keys for the given project matching query.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_search_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_search_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_search_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/search', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[TranslationKey]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_tag_patch(self, project_id, **kwargs):
        """
        Tags all keys matching query. Same constraints as list.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_tag_patch(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_tag_patch_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_tag_patch_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_keys_tag_patch_with_http_info(self, project_id, **kwargs):
        """
        Tags all keys matching query. Same constraints as list.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_tag_patch_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_tag_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_tag_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/tag', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedResources',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_keys_untag_patch(self, project_id, **kwargs):
        """
        Removes specified tags from keys matching query.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_untag_patch(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_keys_untag_patch_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_keys_untag_patch_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_keys_untag_patch_with_http_info(self, project_id, **kwargs):
        """
        Removes specified tags from keys matching query.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_keys_untag_patch_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_keys_untag_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_keys_untag_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/keys/untag', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedResources',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_get(self, project_id, **kwargs):
        """
        List all locales for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Locale]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_locales_get_with_http_info(self, project_id, **kwargs):
        """
        List all locales for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Locale]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Locale]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_id_delete(self, project_id, id, **kwargs):
        """
        Delete an existing locale.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_delete(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_id_delete_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_id_delete_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_locales_id_delete_with_http_info(self, project_id, id, **kwargs):
        """
        Delete an existing locale.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_delete_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_locales_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_id_download_get(self, project_id, id, **kwargs):
        """
        Download a locale in a specific file format.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_download_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_id_download_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_id_download_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_locales_id_download_get_with_http_info(self, project_id, id, **kwargs):
        """
        Download a locale in a specific file format.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_download_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_id_download_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_id_download_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_locales_id_download_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales/{Id}/download', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single locale for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Locale
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_locales_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single locale for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Locale
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_locales_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Locale',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_id_patch(self, project_id, id, **kwargs):
        """
        Update an existing locale.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: LocaleDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_id_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_id_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_locales_id_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Update an existing locale.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_id_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: LocaleDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_locales_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LocaleDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_locale_id_translations_get(self, project_id, locale_id, **kwargs):
        """
        List translations for a specific locale. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_locale_id_translations_get(project_id, locale_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str locale_id: LocaleId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: Translation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_locale_id_translations_get_with_http_info(project_id, locale_id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_locale_id_translations_get_with_http_info(project_id, locale_id, **kwargs)
            return data

    def projects_project_id_locales_locale_id_translations_get_with_http_info(self, project_id, locale_id, **kwargs):
        """
        List translations for a specific locale. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_locale_id_translations_get_with_http_info(project_id, locale_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str locale_id: LocaleId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: Translation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'locale_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_locale_id_translations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_locale_id_translations_get`")
        # verify the required parameter 'locale_id' is set
        if ('locale_id' not in params) or (params['locale_id'] is None):
            raise ValueError("Missing the required parameter `locale_id` when calling `projects_project_id_locales_locale_id_translations_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'locale_id' in params:
            path_params['LocaleId'] = params['locale_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales/{LocaleId}/translations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Translation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_locales_post(self, project_id, **kwargs):
        """
        Create a new locale.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: LocaleDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_locales_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_locales_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_locales_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new locale.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_locales_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: LocaleDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_locales_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_locales_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/locales', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LocaleDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_orders_get(self, project_id, **kwargs):
        """
        List all orders for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationOrder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_orders_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_orders_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_orders_get_with_http_info(self, project_id, **kwargs):
        """
        List all orders for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationOrder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_orders_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_orders_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/orders', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[TranslationOrder]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_orders_id_confirm_patch(self, project_id, id, **kwargs):
        """
        Confirm an existing order and send it to the provider for translation. Same constraints as for create.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_id_confirm_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_orders_id_confirm_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_orders_id_confirm_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_orders_id_confirm_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Confirm an existing order and send it to the provider for translation. Same constraints as for create.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_id_confirm_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_orders_id_confirm_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_orders_id_confirm_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_orders_id_confirm_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/orders/{Id}/confirm', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationOrder',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_orders_id_delete(self, project_id, id, **kwargs):
        """
        Cancel an existing order. Must not yet be confirmed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_id_delete(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_orders_id_delete_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_orders_id_delete_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_orders_id_delete_with_http_info(self, project_id, id, **kwargs):
        """
        Cancel an existing order. Must not yet be confirmed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_id_delete_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_orders_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_orders_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_orders_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/orders/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_orders_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single order.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_orders_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_orders_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_orders_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single order.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_orders_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_orders_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_orders_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/orders/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationOrder',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_orders_post(self, project_id, **kwargs):
        """
        Create a new order. Access token scope must include <code>orders.create</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TranslationOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_orders_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_orders_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_orders_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new order. Access token scope must include <code>orders.create</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_orders_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TranslationOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_orders_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_orders_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/orders', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationOrder',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_styleguides_get(self, project_id, **kwargs):
        """
        List all styleguides for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Styleguide]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_styleguides_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_styleguides_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_styleguides_get_with_http_info(self, project_id, **kwargs):
        """
        List all styleguides for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Styleguide]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_styleguides_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_styleguides_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/styleguides', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Styleguide]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_styleguides_id_delete(self, project_id, id, **kwargs):
        """
        Delete an existing style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_id_delete(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_styleguides_id_delete_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_styleguides_id_delete_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_styleguides_id_delete_with_http_info(self, project_id, id, **kwargs):
        """
        Delete an existing style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_id_delete_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_styleguides_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_styleguides_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_styleguides_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/styleguides/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_styleguides_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Styleguide
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_styleguides_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_styleguides_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_styleguides_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Styleguide
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_styleguides_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_styleguides_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_styleguides_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/styleguides/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Styleguide',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_styleguides_id_patch(self, project_id, id, **kwargs):
        """
        Update an existing style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_id_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: StyleguideDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_styleguides_id_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_styleguides_id_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_styleguides_id_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Update an existing style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_id_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: StyleguideDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_styleguides_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_styleguides_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_styleguides_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/styleguides/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StyleguideDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_styleguides_post(self, project_id, **kwargs):
        """
        Create a new style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: StyleguideDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_styleguides_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_styleguides_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_styleguides_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new style guide.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_styleguides_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: StyleguideDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_styleguides_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_styleguides_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/styleguides', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StyleguideDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_tags_get(self, project_id, **kwargs):
        """
        List all tags for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_tags_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_tags_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_tags_get_with_http_info(self, project_id, **kwargs):
        """
        List all tags for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_tags_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_tags_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/tags', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Tag]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_tags_name_delete(self, project_id, name, **kwargs):
        """
        Delete an existing tag.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_name_delete(project_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str name: Name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_tags_name_delete_with_http_info(project_id, name, **kwargs)
        else:
            (data) = self.projects_project_id_tags_name_delete_with_http_info(project_id, name, **kwargs)
            return data

    def projects_project_id_tags_name_delete_with_http_info(self, project_id, name, **kwargs):
        """
        Delete an existing tag.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_name_delete_with_http_info(project_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str name: Name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_tags_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_tags_name_delete`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `projects_project_id_tags_name_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'name' in params:
            path_params['Name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/tags/{Name}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_tags_name_get(self, project_id, name, **kwargs):
        """
        Get details and progress information on a single tag for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_name_get(project_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str name: Name (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_tags_name_get_with_http_info(project_id, name, **kwargs)
        else:
            (data) = self.projects_project_id_tags_name_get_with_http_info(project_id, name, **kwargs)
            return data

    def projects_project_id_tags_name_get_with_http_info(self, project_id, name, **kwargs):
        """
        Get details and progress information on a single tag for a given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_name_get_with_http_info(project_id, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str name: Name (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_tags_name_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_tags_name_get`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `projects_project_id_tags_name_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'name' in params:
            path_params['Name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/tags/{Name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Tag',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_tags_post(self, project_id, **kwargs):
        """
        Create a new tag.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TagWithStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_tags_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_tags_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_tags_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new tag.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_tags_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TagWithStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_tags_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_tags_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/tags', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TagWithStats',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_exclude_patch(self, project_id, **kwargs):
        """
        Exclude translations matching query from locale export.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_exclude_patch(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_exclude_patch_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_exclude_patch_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_exclude_patch_with_http_info(self, project_id, **kwargs):
        """
        Exclude translations matching query from locale export.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_exclude_patch_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_exclude_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_exclude_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/exclude', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedCount',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_get(self, project_id, **kwargs):
        """
        List translations for the given project. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Translation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_get_with_http_info(self, project_id, **kwargs):
        """
        List translations for the given project. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Translation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Translation]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Translation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_translations_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Translation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_translations_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Translation',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_id_patch(self, project_id, id, **kwargs):
        """
        Update an existing translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_id_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_id_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_id_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_translations_id_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Update an existing translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_id_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: TranslationDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_translations_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_include_patch(self, project_id, **kwargs):
        """
        Include translations matching query in locale export.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_include_patch(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_include_patch_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_include_patch_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_include_patch_with_http_info(self, project_id, **kwargs):
        """
        Include translations matching query in locale export.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_include_patch_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_include_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_include_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/include', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedCount',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_post(self, project_id, **kwargs):
        """
        Create a translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TranslationDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_post_with_http_info(self, project_id, **kwargs):
        """
        Create a translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: TranslationDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationDetails',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_search_post(self, project_id, **kwargs):
        """
        List translations for the given project if you exceed GET request limitations on translations list. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_search_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Translation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_search_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_search_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_search_post_with_http_info(self, project_id, **kwargs):
        """
        List translations for the given project if you exceed GET request limitations on translations list. If you want to download all translations for one locale we recommend to use the <code>locales#download</code> endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_search_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Translation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_search_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_search_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/search', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Translation]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_translation_id_versions_get(self, project_id, translation_id, **kwargs):
        """
        List all versions for the given translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_translation_id_versions_get(project_id, translation_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str translation_id: TranslationId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationVersion]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_translation_id_versions_get_with_http_info(project_id, translation_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_translation_id_versions_get_with_http_info(project_id, translation_id, **kwargs)
            return data

    def projects_project_id_translations_translation_id_versions_get_with_http_info(self, project_id, translation_id, **kwargs):
        """
        List all versions for the given translation.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_translation_id_versions_get_with_http_info(project_id, translation_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str translation_id: TranslationId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[TranslationVersion]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'translation_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_translation_id_versions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_translation_id_versions_get`")
        # verify the required parameter 'translation_id' is set
        if ('translation_id' not in params) or (params['translation_id'] is None):
            raise ValueError("Missing the required parameter `translation_id` when calling `projects_project_id_translations_translation_id_versions_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'translation_id' in params:
            path_params['TranslationId'] = params['translation_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/{TranslationId}/versions', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[TranslationVersion]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_translation_id_versions_id_get(self, project_id, translation_id, id, **kwargs):
        """
        Get details on a single version.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_translation_id_versions_id_get(project_id, translation_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str translation_id: TranslationId (required)
        :param str id: Id (required)
        :return: TranslationVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_translation_id_versions_id_get_with_http_info(project_id, translation_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_translation_id_versions_id_get_with_http_info(project_id, translation_id, id, **kwargs)
            return data

    def projects_project_id_translations_translation_id_versions_id_get_with_http_info(self, project_id, translation_id, id, **kwargs):
        """
        Get details on a single version.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_translation_id_versions_id_get_with_http_info(project_id, translation_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str translation_id: TranslationId (required)
        :param str id: Id (required)
        :return: TranslationVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'translation_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_translation_id_versions_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_translation_id_versions_id_get`")
        # verify the required parameter 'translation_id' is set
        if ('translation_id' not in params) or (params['translation_id'] is None):
            raise ValueError("Missing the required parameter `translation_id` when calling `projects_project_id_translations_translation_id_versions_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_translations_translation_id_versions_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'translation_id' in params:
            path_params['TranslationId'] = params['translation_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/{TranslationId}/versions/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TranslationVersion',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_unverify_patch(self, project_id, **kwargs):
        """
        <div class=\"alert alert-info\">Only available in the <a href=\"https://phraseapp.com/pricing\" target=\"_blank\">Control Package</a>.</div>Mark translations matching query as unverified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_unverify_patch(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_unverify_patch_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_unverify_patch_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_unverify_patch_with_http_info(self, project_id, **kwargs):
        """
        <div class=\"alert alert-info\">Only available in the <a href=\"https://phraseapp.com/pricing\" target=\"_blank\">Control Package</a>.</div>Mark translations matching query as unverified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_unverify_patch_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_unverify_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_unverify_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/unverify', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedCount',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_translations_verify_patch(self, project_id, **kwargs):
        """
        <div class=\"alert alert-info\">Only available in the <a href=\"https://phraseapp.com/pricing\" target=\"_blank\">Control Package</a>.</div>Verify translations matching query.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_verify_patch(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_translations_verify_patch_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_translations_verify_patch_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_translations_verify_patch_with_http_info(self, project_id, **kwargs):
        """
        <div class=\"alert alert-info\">Only available in the <a href=\"https://phraseapp.com/pricing\" target=\"_blank\">Control Package</a>.</div>Verify translations matching query.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_translations_verify_patch_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: AffectedCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_translations_verify_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_translations_verify_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/translations/verify', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AffectedCount',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_uploads_get(self, project_id, **kwargs):
        """
        List all uploads for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_uploads_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Upload]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_uploads_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_uploads_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_uploads_get_with_http_info(self, project_id, **kwargs):
        """
        List all uploads for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_uploads_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Upload]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_uploads_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_uploads_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/uploads', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Upload]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_uploads_id_get(self, project_id, id, **kwargs):
        """
        View details and summary for a single upload.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_uploads_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_uploads_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_uploads_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_uploads_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        View details and summary for a single upload.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_uploads_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_uploads_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_uploads_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_uploads_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/uploads/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Upload',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_uploads_post(self, project_id, **kwargs):
        """
        Upload a new language file. Creates necessary resources in your project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_uploads_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_uploads_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_uploads_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_uploads_post_with_http_info(self, project_id, **kwargs):
        """
        Upload a new language file. Creates necessary resources in your project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_uploads_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_uploads_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_uploads_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/uploads', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Upload',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_webhooks_get(self, project_id, **kwargs):
        """
        List all webhooks for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Webhook]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_webhooks_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_webhooks_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_webhooks_get_with_http_info(self, project_id, **kwargs):
        """
        List all webhooks for the given project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param int per_page: Per Page
        :param int page: Page
        :return: list[Webhook]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'per_page', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhooks_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhooks_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/webhooks', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Webhook]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_webhooks_id_delete(self, project_id, id, **kwargs):
        """
        Delete an existing webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_delete(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_webhooks_id_delete_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_webhooks_id_delete_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_webhooks_id_delete_with_http_info(self, project_id, id, **kwargs):
        """
        Delete an existing webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_delete_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhooks_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhooks_id_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_webhooks_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/webhooks/{Id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_webhooks_id_get(self, project_id, id, **kwargs):
        """
        Get details on a single webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_get(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_webhooks_id_get_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_webhooks_id_get_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_webhooks_id_get_with_http_info(self, project_id, id, **kwargs):
        """
        Get details on a single webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_get_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhooks_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhooks_id_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_webhooks_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/webhooks/{Id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Webhook',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_webhooks_id_patch(self, project_id, id, **kwargs):
        """
        Update an existing webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_patch(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_webhooks_id_patch_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_webhooks_id_patch_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_webhooks_id_patch_with_http_info(self, project_id, id, **kwargs):
        """
        Update an existing webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_patch_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhooks_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhooks_id_patch`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_webhooks_id_patch`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/webhooks/{Id}', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Webhook',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_webhooks_id_test_post(self, project_id, id, **kwargs):
        """
        Perform a test request for a webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_test_post(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_webhooks_id_test_post_with_http_info(project_id, id, **kwargs)
        else:
            (data) = self.projects_project_id_webhooks_id_test_post_with_http_info(project_id, id, **kwargs)
            return data

    def projects_project_id_webhooks_id_test_post_with_http_info(self, project_id, id, **kwargs):
        """
        Perform a test request for a webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_id_test_post_with_http_info(project_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :param str id: Id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhooks_id_test_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhooks_id_test_post`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_webhooks_id_test_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']
        if 'id' in params:
            path_params['Id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/webhooks/{Id}/test', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_webhooks_post(self, project_id, **kwargs):
        """
        Create a new webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_webhooks_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_webhooks_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_webhooks_post_with_http_info(self, project_id, **kwargs):
        """
        Create a new webhook.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_webhooks_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_id: ProjectId (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhooks_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhooks_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['ProjectId'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/projects/{ProjectId}/webhooks', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Webhook',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_get(self, **kwargs):
        """
        Show details for current User.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_get_with_http_info(**kwargs)
        else:
            (data) = self.user_get_with_http_info(**kwargs)
            return data

    def user_get_with_http_info(self, **kwargs):
        """
        Show details for current User.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['headerToken']

        return self.api_client.call_api('/user', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='User',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
